diff --git a/.gitignore b/.gitignore
index 1c8d4b15925..7204cce44a2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,7 +23,7 @@
 
 # Nested build directory
 /build*
-
+/_build
 #==============================================================================#
 # Explicit files to ignore (only matches one).
 #==============================================================================#
diff --git a/clean-build.sh b/clean-build.sh
new file mode 100755
index 00000000000..a642dabdf9c
--- /dev/null
+++ b/clean-build.sh
@@ -0,0 +1,7 @@
+#/bin/bash
+set -e
+rm -rf build
+mkdir build
+cd build
+cmake -G Ninja -DCMAKE_BUILD_TYPE="Release"  -DLLVM_ENABLE_PROJECTS=clang -DBUILD_SHARED_LIBS=False -DLLVM_USE_SPLIT_DWARF=True  -DCMAKE_INSTALL_PREFIX="/home/derry/riscv/"  -DLLVM_OPTIMIZED_TABLEGEN=True -DLLVM_BUILD_TESTS=False -DLLVM_PARALLEL_LINK_JOBS=False -DDEFAULT_SYSROOT="/home/derry/riscv/riscv64-unknown-elf"  -DLLVM_DEFAULT_TARGET_TRIPLE="riscv64-unknown-elf"  -DLLVM_TARGETS_TO_BUILD="RISCV"  ../llvm
+cmake --build . --target install
diff --git a/llvm/lib/Target/RISCV/CMakeLists.txt b/llvm/lib/Target/RISCV/CMakeLists.txt
index 9a0c2209c88..7dcbdc67f37 100644
--- a/llvm/lib/Target/RISCV/CMakeLists.txt
+++ b/llvm/lib/Target/RISCV/CMakeLists.txt
@@ -29,6 +29,7 @@ add_llvm_target(RISCVCodeGen
   RISCVLegalizerInfo.cpp
   RISCVMCInstLower.cpp
   RISCVMergeBaseOffset.cpp
+  RISCVMachineInstrPrinter.cpp
   RISCVRegisterBankInfo.cpp
   RISCVRegisterInfo.cpp
   RISCVSubtarget.cpp
diff --git a/llvm/lib/Target/RISCV/RISCV.h b/llvm/lib/Target/RISCV/RISCV.h
index 9baa2cc2741..f8acbf1177e 100644
--- a/llvm/lib/Target/RISCV/RISCV.h
+++ b/llvm/lib/Target/RISCV/RISCV.h
@@ -30,6 +30,7 @@ class MachineInstr;
 class MachineOperand;
 class PassRegistry;
 
+
 void LowerRISCVMachineInstrToMCInst(const MachineInstr *MI, MCInst &OutMI,
                                     const AsmPrinter &AP);
 bool LowerRISCVMachineOperandToMCOperand(const MachineOperand &MO,
@@ -40,6 +41,9 @@ FunctionPass *createRISCVISelDag(RISCVTargetMachine &TM);
 FunctionPass *createRISCVMergeBaseOffsetOptPass();
 void initializeRISCVMergeBaseOffsetOptPass(PassRegistry &);
 
+FunctionPass *createRISCVMachineInstrPrinterPass();
+void initializeRISCVMachineInstrPrinterPass(PassRegistry &);
+
 FunctionPass *createRISCVExpandPseudoPass();
 void initializeRISCVExpandPseudoPass(PassRegistry &);
 
diff --git a/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp b/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
index 43adc7426c7..8cbd07b3c48 100644
--- a/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
@@ -289,7 +289,39 @@ void RISCVFrameLowering::emitPrologue(MachineFunction &MF,
       MCCFIInstruction::cfiDefCfaOffset(nullptr, RealStackSize));
   BuildMI(MBB, MBBI, DL, TII->get(TargetOpcode::CFI_INSTRUCTION))
       .addCFIIndex(CFIIndex);
-
+  
+
+/*
+  //Set shadow stack address for ex: 80000000
+  //li t6, 0x80000000
+  //became
+  // lui t6,0xfff80000
+  BuildMI(MBB, MBBI, DL, TII->get(RISCV::LUI), RISCV::X31)
+      .addImm(0xfff80000);
+
+  // addi t6, t6, -4
+  BuildMI(MBB, MBBI, DL, TII->get(RISCV::ADDI), RISCV::X31)
+      .addReg(RISCV::X31)
+      .addImm(-4);
+  //
+  //sw ra, 0(t6)
+  BuildMI(MBB, MBBI, DL, TII->get(RISCV::SW), RISCV::X1)
+      .addReg(RISCV::X31)
+      .addImm(0);
+
+  //st zero, 0(t6)
+  BuildMI(MBB, MBBI, DL, TII->get(RISCV::ST), RISCV::X0)
+      .addReg(RISCV::X31)
+      .addImm(0);
+*/
+/*      
+BuildMI(MBB, MBBI, DL, TII->get(RISCV::ADDI), RISCV::X31)
+      .addReg(RISCV::X31)
+      .addImm(-4);
+  BuildMI(MBB, MBBI, DL, TII->get(RISCV::SSW),RISCV::X1)
+      .addReg(RISCV::X31)
+      .addImm(0);
+*/
   const auto &CSI = MFI.getCalleeSavedInfo();
 
   // The frame pointer is callee-saved, and code has been generated for us to
@@ -454,9 +486,20 @@ void RISCVFrameLowering::emitEpilogue(MachineFunction &MF,
 
   if (FirstSPAdjustAmount)
     StackSize = FirstSPAdjustAmount;
-
+  
   // Deallocate stack
   adjustReg(MBB, MBBI, DL, SPReg, SPReg, StackSize, MachineInstr::FrameDestroy);
+
+  //   const RISCVInstrInfo *TII = STI.getInstrInfo();
+  // // load shadow to ra : lw ra, 0(t6)
+  // BuildMI(MBB, MBBI, DL, TII->get(RISCV::LD), RISCV::X1)
+  //           .addReg(RISCV::X31)
+  //           .addImm(0);
+
+  // // restore stack on shadow : addi t6, t6, 4
+  // BuildMI(MBB, MBBI, DL, TII->get(RISCV::ADDI), RISCV::X31)
+  //           .addReg(RISCV::X31)
+  //           .addImm(16);
 }
 
 int RISCVFrameLowering::getFrameIndexReference(const MachineFunction &MF,
diff --git a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
index 7570385e38e..beb88072efa 100644
--- a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
@@ -536,6 +536,7 @@ void RISCVDAGToDAGISel::doPeepholeLoadStoreADDI() {
     case RISCV::LHU:
     case RISCV::LWU:
     case RISCV::LD:
+    case RISCV::LT:
     case RISCV::FLW:
     case RISCV::FLD:
       BaseOpIdx = 0;
@@ -545,6 +546,7 @@ void RISCVDAGToDAGISel::doPeepholeLoadStoreADDI() {
     case RISCV::SH:
     case RISCV::SW:
     case RISCV::SD:
+    case RISCV::ST:
     case RISCV::FSW:
     case RISCV::FSD:
       BaseOpIdx = 1;
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfo.td b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
index b9483062dde..ba3dabc082f 100644
--- a/llvm/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
@@ -527,7 +527,9 @@ def CSRRCI : CSR_ii<0b111, "csrrci">;
 let Predicates = [IsRV64] in {
 def LWU   : Load_ri<0b110, "lwu">, Sched<[WriteLDWU, ReadMemBase]>;
 def LD    : Load_ri<0b011, "ld">, Sched<[WriteLDD, ReadMemBase]>;
+def LT    : Load_ri<0b111, "lt">, Sched<[WriteLDD, ReadMemBase]>;
 def SD    : Store_rri<0b011, "sd">, Sched<[WriteSTD, ReadStoreData, ReadMemBase]>;
+def ST    : Store_rri<0b111, "st">, Sched<[WriteSTD, ReadStoreData, ReadMemBase]>;
 
 let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
 def ADDIW : RVInstI<0b000, OPC_OP_IMM_32, (outs GPR:$rd),
@@ -629,6 +631,8 @@ let Predicates = [IsRV64] in {
 def PseudoLWU : PseudoLoad<"lwu">;
 def PseudoLD  : PseudoLoad<"ld">;
 def PseudoSD  : PseudoStore<"sd">;
+def PseudoLT  : PseudoLoad<"lt">;
+def PseudoST  : PseudoStore<"st">;
 } // Predicates = [IsRV64]
 
 def : InstAlias<"mv $rd, $rs",   (ADDI GPR:$rd, GPR:$rs,       0)>;
@@ -767,6 +771,10 @@ def : InstAlias<"ld $rd, (${rs1})",
                 (LD  GPR:$rd, GPR:$rs1, 0)>;
 def : InstAlias<"sd $rs2, (${rs1})",
                 (SD  GPR:$rs2, GPR:$rs1, 0)>;
+def : InstAlias<"lt $rd, (${rs1})",
+                (LT  GPR:$rd, GPR:$rs1, 0)>;
+def : InstAlias<"st $rs2, (${rs1})",
+                (ST  GPR:$rs2, GPR:$rs1, 0)>;
 
 def : InstAlias<"addw $rd, $rs1, $imm12",
                 (ADDIW  GPR:$rd, GPR:$rs1, simm12:$imm12)>;
@@ -1140,11 +1148,13 @@ defm : LdPat<sextloadi32, LW>;
 defm : LdPat<extloadi32, LW>;
 defm : LdPat<zextloadi32, LWU>;
 defm : LdPat<load, LD>;
+defm : LdPat<load, LT>;
 
 /// Stores
 
 defm : StPat<truncstorei32, SW, GPR>;
 defm : StPat<store, SD, GPR>;
+defm : StPat<store, ST, GPR>;
 } // Predicates = [IsRV64]
 
 /// readcyclecounter
diff --git a/llvm/lib/Target/RISCV/RISCVMachineInstrPrinter.cpp b/llvm/lib/Target/RISCV/RISCVMachineInstrPrinter.cpp
new file mode 100644
index 00000000000..6286e7e89ac
--- /dev/null
+++ b/llvm/lib/Target/RISCV/RISCVMachineInstrPrinter.cpp
@@ -0,0 +1,171 @@
+// derry
+
+#include "RISCV.h"
+#include "RISCVInstrInfo.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/TargetRegisterInfo.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instructions.h"
+#include <iostream>
+#include <utility>
+
+using namespace llvm;
+using namespace std;
+
+#define RISCV_MACHINEINSTR_PRINTER_PASS_NAME                                   \
+  "Dummy RISCV machineinstr printer pass"
+
+namespace {
+
+class RISCVMachineInstrPrinter : public MachineFunctionPass {
+public:
+  static char ID;
+
+  RISCVMachineInstrPrinter() : MachineFunctionPass(ID) {
+    initializeRISCVMachineInstrPrinterPass(*PassRegistry::getPassRegistry());
+  }
+
+  bool runOnMachineFunction(MachineFunction &MF) override;
+
+  StringRef getPassName() const override {
+    return RISCV_MACHINEINSTR_PRINTER_PASS_NAME;
+  }
+};
+
+char RISCVMachineInstrPrinter::ID = 0;
+// TODO: INDIRECT CHECK, if it jumps or not
+// TODO: Function what can we read inside
+// TODO: Switch case ins become what?
+int idx = 0;
+pair<string, int> func[10];
+bool RISCVMachineInstrPrinter::runOnMachineFunction(MachineFunction &MF) {
+  int x = 0;
+  bool is_instrumented = false;
+  for (auto &MBB : MF) {
+
+    for (auto &MI : MBB) {
+      MachineInstr *currInstrPtr = &MI;
+
+      // outs() << "FIRST INST\n";
+      const TargetInstrInfo *XII =
+          MF.getSubtarget().getInstrInfo(); // target instruction info
+      DebugLoc DL;
+      // is this a very first block?
+      if (x == 0) {
+        if (MF.getName() == "main") {
+          // // allocate stack for shadow stack
+
+          // // Copy SP to T6: addi x31, x2, 0
+          // MachineBasicBlock::iterator MBBI =
+          //     BuildMI(MBB, MI, DL, XII->get(RISCV::ADDI), RISCV::X31)
+          //         .addReg(RISCV::X2)
+          //         .addImm(0);
+
+          // // Copy Load 0x100 000 (MB) to T5 : lui x30, 0x100
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::LUI),
+          // RISCV::X30).addImm(0x400);
+
+          // // Decrease SP : sub x2, x2, x30
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::SUB), RISCV::X2)
+          //     .addReg(RISCV::X2)
+          //     .addReg(RISCV::X30);
+
+          // is_instrumented = true;
+        } else {
+          // allocate stack on shadow : addi t6, t6, -4
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::ADDI), RISCV::X31)
+          //     .addReg(RISCV::X31)
+          //     .addImm(-16);
+          // // START_MPK
+          // // Clear AD and WD on Tag 0
+          // // https://github.com/riscv/riscv-asm-manual/blob/master/riscv-asm.md#pseudoinstructions-for-accessing-control-and-status-registers
+          // // csrrci x0, csr, imm
+          // // csrrs rd, csr, x0
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::CSRRS), RISCV::X0)
+          //     .addImm(0xC00)
+          //     .addReg(RISCV::X0);
+
+          // // csrrci x0, csr, imm
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::CSRRS), RISCV::X0)
+          //     .addImm(0xC00)
+          //     .addReg(RISCV::X0);
+          // // END_MPK
+
+          // // save ra to shadow : sw ra, 0(t6)
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::SD), RISCV::X1)
+          //     .addReg(RISCV::X31)
+          //     .addImm(0);
+
+          // // save ra to shadow : sw ra, 0(t6)
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::SD), RISCV::X1)
+          //     .addReg(RISCV::X31)
+          //     .addImm(0);
+
+          // // START_MPK
+          // // Set AD and WD on Tag 0
+          // // csrrsi x0, csr, imm
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::CSRRS), RISCV::X0)
+          //     .addImm(0xC00)
+          //     .addReg(RISCV::X0);
+          // // csrrsi x0, csr, imm
+          // BuildMI(MBB, MI, DL, XII->get(RISCV::CSRRS), RISCV::X0)
+          //     .addImm(0xC00)
+          //     .addReg(RISCV::X0);
+          // // END_MPK
+          // is_instrumented = true;
+        }
+      }
+
+      if (MI.isReturn() && MF.getName() != "main") {
+        // // START_MPK
+        // // Clear AD on Tag 0
+        // // csrrci x0, csr, imm
+        //   BuildMI(MBB, MI, DL, XII->get(RISCV::CSRRS), RISCV::X0)
+        //       .addImm(0xC00)
+        //       .addReg(RISCV::X0);
+        // // END_MPK
+
+        // // load shadow to ra : lw ra, 0(t6)
+        // BuildMI(MBB, MI, DL, XII->get(RISCV::LD), RISCV::X1)
+        //     .addReg(RISCV::X31)
+        //     .addImm(0);
+
+        // // START_MPK
+        // // Set AD on Tag 0
+        // // csrrsi x0, csr, imm
+        //   BuildMI(MBB, MI, DL, XII->get(RISCV::CSRRS), RISCV::X0)
+        //       .addImm(0xC00)
+        //       .addReg(RISCV::X0);
+        // // END_MPK
+
+        // // restore stack on shadow : addi t6, t6, 4
+        // BuildMI(MBB, MI, DL, XII->get(RISCV::ADDI), RISCV::X31)
+        //     .addReg(RISCV::X31)
+        //     .addImm(16);
+
+        // is_instrumented = true;
+      }
+
+      x++;
+    }
+  }
+
+  return is_instrumented;
+}
+
+} // end of anonymous namespace
+
+INITIALIZE_PASS(RISCVMachineInstrPrinter, "RISCV-machineinstr-printer",
+                RISCV_MACHINEINSTR_PRINTER_PASS_NAME,
+                true, // is CFG only?
+                true  // is analysis?
+)
+
+namespace llvm {
+
+FunctionPass *createRISCVMachineInstrPrinterPass() {
+  return new RISCVMachineInstrPrinter();
+}
+
+} // namespace llvm
\ No newline at end of file
diff --git a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
index cb7d55eb0f0..a0a08d1680b 100644
--- a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -83,6 +83,7 @@ BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
   markSuperRegs(Reserved, RISCV::X2); // sp
   markSuperRegs(Reserved, RISCV::X3); // gp
   markSuperRegs(Reserved, RISCV::X4); // tp
+  Reserved.set(RISCV::X31); //t6
   if (TFI->hasFP(MF))
     markSuperRegs(Reserved, RISCV::X8); // fp
   // Reserve the base register if we need to realign the stack and allocate
diff --git a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
index 75683e2fd8e..9d2ea1b66dd 100644
--- a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
+++ b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
@@ -38,6 +38,7 @@ extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeRISCVTarget() {
   auto PR = PassRegistry::getPassRegistry();
   initializeGlobalISel(*PR);
   initializeRISCVExpandPseudoPass(*PR);
+  initializeRISCVMachineInstrPrinterPass(*PR);
 }
 
 static StringRef computeDataLayout(const Triple &TT) {
@@ -131,7 +132,7 @@ public:
   void addPreSched2() override;
   void addPreRegAlloc() override;
 };
-}
+} // namespace
 
 TargetPassConfig *RISCVTargetMachine::createPassConfig(PassManagerBase &PM) {
   return new RISCVPassConfig(*this, PM);
@@ -178,6 +179,7 @@ void RISCVPassConfig::addPreEmitPass2() {
   // possibility for other passes to break the requirements for forward
   // progress in the LR/SC block.
   addPass(createRISCVExpandAtomicPseudoPass());
+  addPass(createRISCVMachineInstrPrinterPass());
 }
 
 void RISCVPassConfig::addPreRegAlloc() {
diff --git a/llvm/lib/Transforms/Hello/Hello.cpp b/llvm/lib/Transforms/Hello/Hello.cpp
index b0adb5401f8..c1f0537647e 100644
--- a/llvm/lib/Transforms/Hello/Hello.cpp
+++ b/llvm/lib/Transforms/Hello/Hello.cpp
@@ -13,52 +13,112 @@
 
 #include "llvm/ADT/Statistic.h"
 #include "llvm/IR/Function.h"
+#include "llvm/IR/Instructions.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/raw_ostream.h"
+#include <utility>
+#include <iostream>
+
 using namespace llvm;
+using namespace std;
 
 #define DEBUG_TYPE "hello"
 
 STATISTIC(HelloCounter, "Counts number of functions greeted");
 
+pair <string, int> func[10];
 namespace {
-  // Hello - The first implementation, without getAnalysisUsage.
-  struct Hello : public FunctionPass {
-    static char ID; // Pass identification, replacement for typeid
-    Hello() : FunctionPass(ID) {}
+// Hello - The first implementation, without getAnalysisUsage.
+struct Hello : public FunctionPass {
+  static char ID; // Pass identification, replacement for typeid
+  Hello() : FunctionPass(ID) {}
+  int idx = 0;
+  bool runOnFunction(Function &F) override {
+    ++HelloCounter;
+    errs() << "Hello: ";
+    errs().write_escaped(F.getName()) << '\n';
+    errs() << F.arg_size() << '\n';
+    string a = F.getName().str();
+    func[idx++] = make_pair(a, F.arg_size());
+    for (auto &B : F) {
+      // errs() << "Basic block:\n";
+      // B.print(llvm::errs());
+
+      for (auto &I : B) {
+        Instruction *currInstrPtr = &I;
+        // is this a call instruction?
+        if (CallBase *CI = dyn_cast<CallBase>(currInstrPtr)) {
+          Function *CalledF = CI->getCalledFunction();
+          if (CalledF != NULL) {
+            errs() << CalledF->getName() << "\n";
+          } else {
+            Type *t = CI->getCalledOperand()->getType();
+            errs() << "Waw\n";
+            Value *v = CI->getCalledOperand();
+            Value *sv = v->stripPointerCasts();
+            StringRef fname = sv->getName();
+            errs() << fname << "\n";
+
+            FunctionType *ft =
+                cast<FunctionType>(cast<PointerType>(t)->getElementType());
+          }
 
-    bool runOnFunction(Function &F) override {
-      ++HelloCounter;
-      errs() << "Hello: ";
-      errs().write_escaped(F.getName()) << '\n';
-      return false;
+          errs() << "Instruction: \n";
+          I.print(llvm::errs());
+          errs() << "\nOperanNum: ";
+          errs() << I.getNumOperands() << '\n';
+          errs() << I.GetElementPtr << '\n';
+          // Function * calledFunc =
+          // dyn_cast<Function>(CI->getCalledFunction()->getNumOperands());
+          errs() << "\nFuncname: ";
+          for(int i=0;i<idx;i++) {
+            if(func[i].first.compare(CI->getArgOperand(0)->getName().str()) == 0){
+               errs() << func[i].first << func[i].second << '\n';
+            }
+          }
+          /*if (CI->isIndirectCall()) {
+            errs() << CI->getArgOperand(0)->getName() << '\n';
+            Function *calledFunc =
+                dyn_cast<Function>(CI->getArgOperand(0)->stripPointerCasts()->);
+            errs() << calledFunc->getName() << '\n';
+            errs() << "\n";
+          }*/
+          /*
+          errs() << "Opcode: \n";
+          errs() << I.getOpcode();
+          errs() << "\n";
+          */
+        }
+      }
     }
-  };
-}
+    return false;
+  }
+};
+} // namespace
 
 char Hello::ID = 0;
 static RegisterPass<Hello> X("hello", "Hello World Pass");
 
 namespace {
-  // Hello2 - The second implementation with getAnalysisUsage implemented.
-  struct Hello2 : public FunctionPass {
-    static char ID; // Pass identification, replacement for typeid
-    Hello2() : FunctionPass(ID) {}
+// Hello2 - The second implementation with getAnalysisUsage implemented.
+struct Hello2 : public FunctionPass {
+  static char ID; // Pass identification, replacement for typeid
+  Hello2() : FunctionPass(ID) {}
 
-    bool runOnFunction(Function &F) override {
-      ++HelloCounter;
-      errs() << "Hello: ";
-      errs().write_escaped(F.getName()) << '\n';
-      return false;
-    }
+  bool runOnFunction(Function &F) override {
+    ++HelloCounter;
+    errs() << "Hello: ";
+    errs().write_escaped(F.getName()) << '\n';
+    return false;
+  }
 
-    // We don't modify the program, so we preserve all analyses.
-    void getAnalysisUsage(AnalysisUsage &AU) const override {
-      AU.setPreservesAll();
-    }
-  };
-}
+  // We don't modify the program, so we preserve all analyses.
+  void getAnalysisUsage(AnalysisUsage &AU) const override {
+    AU.setPreservesAll();
+  }
+};
+} // namespace
 
 char Hello2::ID = 0;
 static RegisterPass<Hello2>
-Y("hello2", "Hello World Pass (with getAnalysisUsage implemented)");
+    Y("hello2", "Hello World Pass (with getAnalysisUsage implemented)");
diff --git a/rebuild.sh b/rebuild.sh
new file mode 100755
index 00000000000..b17178d164d
--- /dev/null
+++ b/rebuild.sh
@@ -0,0 +1,8 @@
+#/bin/bash
+set -e
+#rm -rf build
+#mkdir build
+pushd build
+cmake -G Ninja -DCMAKE_BUILD_TYPE="Release"  -DLLVM_ENABLE_PROJECTS=clang -DBUILD_SHARED_LIBS=False -DLLVM_USE_SPLIT_DWARF=True  -DCMAKE_INSTALL_PREFIX="/home/derry/riscv/"  -DLLVM_OPTIMIZED_TABLEGEN=True -DLLVM_BUILD_TESTS=False -DLLVM_PARALLEL_LINK_JOBS=False -DDEFAULT_SYSROOT="/home/derry/riscv/riscv64-unknown-elf"  -DLLVM_DEFAULT_TARGET_TRIPLE="riscv64-unknown-elf"  -DLLVM_TARGETS_TO_BUILD="RISCV"  ../llvm
+cmake --build . --target install
+popd
\ No newline at end of file
